<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>折射線模擬器</title>
  <style>
    canvas {
      border: 1px solid #888;
      margin-top: 1rem;
    }
    select, button {
      margin-right: 1rem;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <h2>折射線模擬器（純前端）</h2>
  <label>上方介質：</label>
  <select id="n1">
    <option value="1.0003">空氣</option>
    <option value="1.333">水</option>
    <option value="1.50">玻璃</option>
    <option value="2.42">鑽石</option>
  </select>

  <label>下方介質：</label>
  <select id="n2">
    <option value="1.333">水</option>
    <option value="1.50">玻璃</option>
    <option value="2.42">鑽石</option>
  </select>

  <input type="file" id="imageUpload">
  <button onclick="resetCanvas()">重新開始</button>

  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imgInput = document.getElementById('imageUpload');

    let image = new Image();
    let state = 0;
    const points = [];

    imgInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(evt) {
          image.onload = () => {
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0);
          };
          image.src = evt.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    function resetCanvas() {
      state = 0;
      points.length = 0;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);
    }

    function drawLine(p1, p2, color) {
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function normalize(v) {
      const len = Math.hypot(v.x, v.y);
      return { x: v.x / len, y: v.y / len };
    }

    function dot(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y;
    }

    function reflect(v, n) {
      const d = dot(v, n);
      return { x: v.x - 2 * d * n.x, y: v.y - 2 * d * n.y };
    }

    function refract(v, n, n1, n2) {
      const cosi = -dot(v, n);
      const eta = n1 / n2;
      const k = 1 - eta * eta * (1 - cosi * cosi);
      if (k < 0) return null;
      return {
        x: eta * v.x + (eta * cosi - Math.sqrt(k)) * n.x,
        y: eta * v.y + (eta * cosi - Math.sqrt(k)) * n.y
      };
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      points.push({ x, y });

      if (state === 0 || state === 1) ctx.fillStyle = 'red';
      else ctx.fillStyle = 'blue';
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();

      if (++state === 4) {
        drawLine(points[0], points[1], 'red');
        drawLine(points[2], points[3], 'blue');

        const n1 = parseFloat(document.getElementById('n1').value);
        const n2 = parseFloat(document.getElementById('n2').value);

        const px = points[0];
        const py = points[1];
        const rx = points[2];
        const ry = points[3];

        const denom = (px.x - py.x) * (rx.y - ry.y) - (px.y - py.y) * (rx.x - ry.x);
        if (denom === 0) return;

        const t = ((px.x - rx.x) * (rx.y - ry.y) - (px.y - rx.y) * (rx.x - ry.x)) / denom;
        const intersection = {
          x: px.x + t * (py.x - px.x),
          y: px.y + t * (py.y - px.y)
        };

        const dx = py.x - px.x;
        const dy = py.y - px.y;
        const normal = normalize({ x: -dy, y: dx });
        drawLine(
          { x: intersection.x - normal.x * 50, y: intersection.y - normal.y * 50 },
          { x: intersection.x + normal.x * 50, y: intersection.y + normal.y * 50 },
          'green'
        );

        const incident = normalize({ x: rx.x - intersection.x, y: ry.y - intersection.y });
        const reflectVec = reflect(incident, normal);
        drawLine(intersection, {
          x: intersection.x + reflectVec.x * 100,
          y: intersection.y + reflectVec.y * 100
        }, 'yellow');

        const refractVec = refract(incident, normal, n1, n2);
        if (refractVec) {
          drawLine(intersection, {
            x: intersection.x + refractVec.x * 100,
            y: intersection.y + refractVec.y * 100
          }, 'purple');
        } else {
          alert("⚠️ 發生全反射");
        }
      }
    });
  </script>
</body>
</html>

